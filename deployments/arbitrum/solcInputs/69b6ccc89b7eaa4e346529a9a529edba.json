{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/facets/AdminFacet.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n\npragma solidity 0.8.18;\n\nimport \"../storage/LibAppStorage.sol\";\n\nimport {LibDiamond} from \"hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol\";\n\n/// @notice Caller of any function in this facet must be the admin address\ncontract AdminFacet {\n    event SetProtocolFeeBasePercentage(uint256 protocolFeeBasePercentage);\n    event SetCursedBondPercentage(uint256 cursedBondPercentage);\n    event WithdrawProtocolFees(uint256 totalProtocolFees, address withdrawalAddress);\n    event SetGracePeriod(uint256 gracePeriod);\n    event SetEmbalmerClaimWindow(uint256 embalmerClaimWindow);\n    event SetExpirationThreshold(uint256 expirationThreshold);\n    event AdminTransferred(address indexed previousAdmin, address indexed newAdmin);\n\n    /// @notice Admin has attempted to set a zero value\n    error CannotSetZeroValue();\n\n    /// @notice Caller must be the admin address\n    error CallerIsNotAdminOrOwner();\n\n    /// @notice Provided address cannot be zero address\n    error ZeroAddress();\n\n    /// @notice Modifier to enforce caller is admin or contract owner\n    modifier onlyAdmin {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        if (msg.sender != s.admin && msg.sender != LibDiamond.contractOwner()) {\n            revert CallerIsNotAdminOrOwner();\n        }\n        _;\n    }\n\n    /// @notice Withdraws the total protocol fee amount from the contract to the specified address\n    /// @param withdrawalAddress - the address to withdraw funds to\n    function withdrawProtocolFees(address withdrawalAddress) external onlyAdmin {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        // Get the total protocol fees from storage\n        uint256 totalProtocolFees = s.totalProtocolFees;\n        // Set the total protocol fees to 0 before the transfer to avoid reentrancy\n        s.totalProtocolFees = 0;\n        // Transfer the protocol fee amount to the sender after setting state\n        s.sarcoToken.transfer(withdrawalAddress, totalProtocolFees);\n        emit WithdrawProtocolFees(totalProtocolFees, withdrawalAddress);\n    }\n\n    /// @notice Sets the protocol fee base percentage, used to calculate protocol fees\n    /// @notice The denominator is 10000\n    /// @param protocolFeeBasePercentage percentage to set\n    function setProtocolFeeBasePercentage(uint256 protocolFeeBasePercentage) external onlyAdmin {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        s.protocolFeeBasePercentage = protocolFeeBasePercentage;\n        emit SetProtocolFeeBasePercentage(protocolFeeBasePercentage);\n    }\n\n    /// @notice Sets the digging fee / cursed bond ratio\n    /// @notice The denominator is 10000\n    /// used to calculate how much bond archaeologists must lock per curse.\n    /// @param cursedBondPercentage ratio to set.\n    function setCursedBondPercentage(uint256 cursedBondPercentage) external onlyAdmin {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        if (cursedBondPercentage == 0) {\n            revert CannotSetZeroValue();\n        }\n        s.cursedBondPercentage = cursedBondPercentage;\n        emit SetCursedBondPercentage(cursedBondPercentage);\n    }\n\n    /// @notice Updates the resurrection grace period\n    /// @notice Denominated in seconds\n    /// @param gracePeriod to set\n    function setGracePeriod(uint256 gracePeriod) external onlyAdmin {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        s.gracePeriod = gracePeriod;\n        emit SetGracePeriod(gracePeriod);\n    }\n\n    /// @notice Updates the embalmerClaimWindow\n    /// @notice Denominated in seconds\n    /// @param embalmerClaimWindow to set\n    function setEmbalmerClaimWindow(uint256 embalmerClaimWindow) external onlyAdmin {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        s.embalmerClaimWindow = embalmerClaimWindow;\n        emit SetEmbalmerClaimWindow(embalmerClaimWindow);\n    }\n\n    /// @notice Updates the expirationThreshold used during sarcophagus creation\n    /// @notice Denominated in seconds\n    /// @param expirationThreshold to set\n    function setExpirationThreshold(uint256 expirationThreshold) external onlyAdmin {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        s.expirationThreshold = expirationThreshold;\n        emit SetExpirationThreshold(expirationThreshold);\n    }\n\n    /// @notice Transfers admin address to newAdmin.\n    /// @param newAdmin to set\n    function transferAdmin(address newAdmin) external onlyAdmin {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        if (newAdmin == address(0)) {\n            revert ZeroAddress();\n        }\n        s.admin = newAdmin;\n        emit AdminTransferred(msg.sender, newAdmin);\n    }\n\n    /// @notice Transfers diamond owner to new owner.\n    /// @param newOwner to set\n    function transferDiamondOwner(address newOwner) external {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.setContractOwner(newOwner);\n    }\n\n    /// @notice Returns current owner of Diamond contract.\n    function getDiamondOwner() external view returns (address) {\n        return LibDiamond.contractOwner();\n    }\n}\n"
    },
    "contracts/facets/ArchaeologistFacet.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../libraries/LibTypes.sol\";\nimport \"../storage/LibAppStorage.sol\";\nimport {LibUtils} from \"../libraries/LibUtils.sol\";\nimport {LibPrivateKeys} from \"../libraries/LibPrivateKeys.sol\";\nimport {LibErrors} from \"../libraries/LibErrors.sol\";\nimport {LibBonds} from \"../libraries/LibBonds.sol\";\n\ncontract ArchaeologistFacet {\n    /// @notice Emitted when an archaeologist successfully publishes their private key for a sarcophagus\n    /// @param sarcoId ID of sarcophagus archaeologist has published the private key on\n    /// @param privateKey private key that has been published\n    event PublishPrivateKey(\n        bytes32 indexed sarcoId,\n        bytes32 privateKey,\n        address indexed archaeologist\n    );\n\n    event DepositFreeBond(address indexed archaeologist, uint256 depositedBond);\n\n    event RegisterArchaeologist(\n        address indexed archaeologist,\n        string peerId,\n        uint256 minimumDiggingFee,\n        uint256 maximumRewrapInterval,\n        uint256 freeBond,\n        uint256 maximumResurrectionTime,\n        uint256 curseFee\n    );\n\n    event UpdateArchaeologist(\n        address indexed archaeologist,\n        string peerId,\n        uint256 minimumDiggingFee,\n        uint256 maximumRewrapInterval,\n        uint256 freeBond,\n        uint256 maximumResurrectionTime,\n        uint256 curseFee\n    );\n\n    event WithdrawFreeBond(address indexed archaeologist, uint256 withdrawnBond);\n\n    event WithdrawReward(address indexed archaeologist, uint256 withdrawnReward);\n\n    /// @notice An archaeologist that has already been successfully accused has attempted to publish their private key\n    /// @param archaeologistAddress Address of accused archaeologist who is attempting to publish their private key\n    /// @param sarcoId ID of sarcophagus archaeologist has attempted to publish a key on\n    error ArchaeologistHasBeenAccused(address archaeologistAddress, bytes32 sarcoId);\n\n    /// @notice Archaeologist has attempted to publish a key before the resurrection time\n    /// @param currentTime Timestamp of the failed publish attempt\n    /// @param resurrectionTime Time after which the sarcophagus can be resurrected\n    error TooEarlyForPublish(uint256 currentTime, uint256 resurrectionTime);\n\n    /// @notice Archaeologist has attempted to publish a key after the end of the resurrection window\n    /// @param currentTime Timestamp of the failed publish attempt\n    /// @param publishDeadline Time after which the sarcophagus can no longer be resurrected  (resurrectionTime + gracePeriod)\n    error TooLateForPublish(uint256 currentTime, uint256 publishDeadline);\n\n    /// @notice Archaeologist has attempted to publish a key for a sarcophagus twice\n    /// @param archaeologistAddress address of publishing archaeologist\n    error ArchaeologistAlreadyPublishedPrivateKey(address archaeologistAddress);\n\n    /// @notice Archaeologist has attempted to set a zero minimumDiggingFeePerSecond or maximumRewrapInterval\n    error CannotSetZeroProfileValue();\n\n    /// @notice Archaeologist has attempted to publish the incorrect private key for a sarcophagus\n    /// @param archaeologistAddress address of publishing archaeologist\n    /// @param publicKey publicKey stored for archaeologist on the sarcophagus\n    /// @param privateKey privateKey the archaeologist has attempted to publish\n    error ArchaeologistPublishedIncorrectPrivateKey(\n        address archaeologistAddress,\n        bytes publicKey,\n        bytes32 privateKey\n    );\n\n    /// @notice Registers the archaeologist profile\n    /// @param peerId The libp2p identifier for the archaeologist\n    /// @param minimumDiggingFeePerSecond The archaeologist's minimum amount to earn per second for being cursed\n    /// @param maximumRewrapInterval The longest interval of time from a rewrap time the arch will accept\n    /// for a resurrection\n    /// @param freeBond How much bond the archaeologist wants to deposit during the register call (if any)\n    /// @param maximumResurrectionTime The time beyond which the archaeologist is not willing to accept new curses or rewraps\n    /// @param curseFee The fee the archaeologist sets to roughly cover the cost of a publishPrivateKey transaction\n    function registerArchaeologist(\n        string memory peerId,\n        uint256 minimumDiggingFeePerSecond,\n        uint256 maximumRewrapInterval,\n        uint256 freeBond,\n        uint256 maximumResurrectionTime,\n        uint256 curseFee\n    ) external {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        // verify that the archaeologist does not already exist\n        LibUtils.revertIfArchProfileExists(msg.sender);\n\n        if (maximumRewrapInterval == 0 || minimumDiggingFeePerSecond == 0) {\n            revert CannotSetZeroProfileValue();\n        }\n\n        // create a new archaeologist\n        LibTypes.ArchaeologistProfile memory newArch = LibTypes.ArchaeologistProfile({\n            peerId: peerId,\n            minimumDiggingFeePerSecond: minimumDiggingFeePerSecond,\n            maximumResurrectionTime: maximumResurrectionTime,\n            maximumRewrapInterval: maximumRewrapInterval,\n            freeBond: freeBond,\n            cursedBond: 0,\n            curseFee: curseFee\n        });\n\n        // transfer SARCO tokens from the archaeologist to this contract, to be\n        // used as their free bond. can be 0.\n        if (freeBond != 0) {\n            s.sarcoToken.transferFrom(msg.sender, address(this), freeBond);\n        }\n\n        // save the new archaeologist into relevant data structures\n        s.archaeologistProfiles[msg.sender] = newArch;\n        s.archaeologistProfileAddresses.push(msg.sender);\n\n        emit RegisterArchaeologist(\n            msg.sender,\n            newArch.peerId,\n            newArch.minimumDiggingFeePerSecond,\n            newArch.maximumRewrapInterval,\n            newArch.freeBond,\n            newArch.maximumResurrectionTime,\n            newArch.curseFee\n        );\n    }\n\n    /// @notice Updates the archaeologist profile\n    /// @param peerId The libp2p identifier for the archaeologist\n    /// @param minimumDiggingFeePerSecond The archaeologist's minimum amount to earn per second for being cursed\n    /// @param freeBond How much bond the archaeologist wants to deposit during the update call (if any)\n    /// @param maximumRewrapInterval The longest interval of time from a rewrap time the arch will accept\n    /// for a resurrection\n    /// @param curseFee The fee the archaeologist sets to roughly cover the cost of a publishPrivateKey transaction\n    function updateArchaeologist(\n        string memory peerId,\n        uint256 minimumDiggingFeePerSecond,\n        uint256 maximumRewrapInterval,\n        uint256 freeBond,\n        uint256 maximumResurrectionTime,\n        uint256 curseFee\n    ) external {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        // verify that the archaeologist exists\n        LibUtils.revertIfArchProfileDoesNotExist(msg.sender);\n\n        if (maximumRewrapInterval == 0 || minimumDiggingFeePerSecond == 0) {\n            revert CannotSetZeroProfileValue();\n        }\n\n        LibTypes.ArchaeologistProfile storage existingArch = s.archaeologistProfiles[msg.sender];\n        existingArch.peerId = peerId;\n        existingArch.minimumDiggingFeePerSecond = minimumDiggingFeePerSecond;\n        existingArch.maximumRewrapInterval = maximumRewrapInterval;\n        existingArch.maximumResurrectionTime = maximumResurrectionTime;\n        existingArch.curseFee = curseFee;\n\n        // transfer SARCO tokens from the archaeologist to this contract, to be\n        // used as their free bond. can be 0.\n        if (freeBond != 0) {\n            s.archaeologistProfiles[msg.sender].freeBond += freeBond;\n            s.sarcoToken.transferFrom(msg.sender, address(this), freeBond);\n        }\n\n        emit UpdateArchaeologist(\n            msg.sender,\n            existingArch.peerId,\n            existingArch.minimumDiggingFeePerSecond,\n            existingArch.maximumRewrapInterval,\n            freeBond,\n            existingArch.maximumResurrectionTime,\n            existingArch.curseFee\n        );\n    }\n\n    /// @notice Deposits an archaeologist's free bond to the contract.\n    /// @param amount The amount to deposit\n    function depositFreeBond(uint256 amount) external {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        LibUtils.revertIfArchProfileDoesNotExist(msg.sender);\n\n        // Increase the archaeologist's free bond in app storage\n        s.archaeologistProfiles[msg.sender].freeBond += amount;\n\n        // Transfer the amount of sarcoToken from the archaeologist to the contract\n        s.sarcoToken.transferFrom(msg.sender, address(this), amount);\n        // Emit an event\n        emit DepositFreeBond(msg.sender, amount);\n    }\n\n    /// @notice Withdraws an archaeologist's free bond from the contract.\n    /// @param amount The amount to withdraw\n    function withdrawFreeBond(uint256 amount) external {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        LibUtils.revertIfArchProfileDoesNotExist(msg.sender);\n        // Decrease the archaeologist's free bond amount.\n        // Reverts if there is not enough free bond on the contract.\n        s.archaeologistProfiles[msg.sender].freeBond -= amount;\n\n        // Transfer the amount of sarcoToken to the archaeologist\n        s.sarcoToken.transfer(msg.sender, amount);\n\n        emit WithdrawFreeBond(msg.sender, amount);\n    }\n\n    /// @notice Withdraws all rewards from an archaeologist's reward pool\n    function withdrawReward() external {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        uint256 amountToWithdraw = s.archaeologistRewards[msg.sender];\n        s.archaeologistRewards[msg.sender] = 0;\n\n        // Transfer the amount of sarcoToken to the archaeologist\n        s.sarcoToken.transfer(msg.sender, amountToWithdraw);\n\n        emit WithdrawReward(msg.sender, amountToWithdraw);\n    }\n\n    /// @notice Publishes the private key for which the archaeologist is responsible during the\n    /// sarcophagus resurrection window.\n    /// Pays digging fees to the archaeologist and releases their locked bond.\n    /// Cannot be called on a compromised or buried sarcophagus.\n    /// @param sarcoId The identifier of the sarcophagus for which the archaeologist is responsible\n    /// @param privateKey The private key the archaeologist is publishing\n    function publishPrivateKey(bytes32 sarcoId, bytes32 privateKey) external {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\n\n        // Confirm sarcophagus exists\n        if (sarcophagus.resurrectionTime == 0) {\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\n        }\n\n        // Confirm sarcophagus has not been compromised\n        if (sarcophagus.isCompromised) {\n            revert LibErrors.SarcophagusCompromised(sarcoId);\n        }\n\n        // Confirm sarcophagus is not buried\n        if (sarcophagus.resurrectionTime == type(uint256).max) {\n            revert LibErrors.SarcophagusInactive(sarcoId);\n        }\n\n        // Confirm current time is after resurrectionTime\n        if (block.timestamp < sarcophagus.resurrectionTime) {\n            revert TooEarlyForPublish(block.timestamp, sarcophagus.resurrectionTime);\n        }\n\n        // Confirm current time is within gracePeriod\n        if (block.timestamp > sarcophagus.resurrectionTime + s.gracePeriod) {\n            revert TooLateForPublish(block.timestamp, sarcophagus.resurrectionTime + s.gracePeriod);\n        }\n\n        // Confirm tx sender is an archaeologist on the sarcophagus\n        LibTypes.CursedArchaeologist storage cursedArchaeologist = s\n            .sarcophagi[sarcoId]\n            .cursedArchaeologists[msg.sender];\n        if (cursedArchaeologist.publicKey.length == 0) {\n            revert LibErrors.ArchaeologistNotOnSarcophagus(msg.sender);\n        }\n\n        // Confirm archaeologist has not already leaked their private key\n        if (cursedArchaeologist.isAccused) {\n            revert ArchaeologistHasBeenAccused(msg.sender, sarcoId);\n        }\n\n        // Confirm archaeologist has not already published their private key\n        if (cursedArchaeologist.privateKey != 0) {\n            revert ArchaeologistAlreadyPublishedPrivateKey(msg.sender);\n        }\n\n        // Confirm that the private key being submitted matches the public key stored on the\n        // sarcophagus for this archaeologist\n        if (!LibPrivateKeys.isPublicKeyOfPrivateKey(privateKey, cursedArchaeologist.publicKey)) {\n            revert ArchaeologistPublishedIncorrectPrivateKey(\n                msg.sender,\n                cursedArchaeologist.publicKey,\n                privateKey\n            );\n        }\n\n        // Store the private key on cursed archaeologist\n        cursedArchaeologist.privateKey = privateKey;\n\n        // Free archaeologist locked bond and transfer digging fees\n        LibBonds.freeArchaeologist(sarcoId, msg.sender);\n\n        emit PublishPrivateKey(sarcoId, privateKey, msg.sender);\n    }\n}\n"
    },
    "contracts/facets/EmbalmerFacet.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"../libraries/LibTypes.sol\";\nimport \"../storage/LibAppStorage.sol\";\nimport {LibErrors} from \"../libraries/LibErrors.sol\";\nimport {LibBonds} from \"../libraries/LibBonds.sol\";\nimport {LibUtils} from \"../libraries/LibUtils.sol\";\n\ncontract EmbalmerFacet {\n    /// @notice Emitted when a sarcophagus is created\n    /// @param sarcoId Id of the new sarcophagus\n    /// @param name Name of the new sarcophagus\n    /// @param resurrectionTime Resurrection time of the new sarcophagus\n    /// @param creationTime Creation time as set during negotiation, not the same as blocktime at which event is emitted\n    /// @param embalmer Address of embalmer\n    /// @param recipient Address of recipient\n    /// @param cursedArchaeologists Array of addresses of cursed archaeologists\n    /// @param totalDiggingFees Total digging fees charged to embalmer to create the sarcophagus\n    /// @param arweaveTxId arweave tx id for the sarcophagus\n    event CreateSarcophagus(\n        bytes32 indexed sarcoId,\n        string name,\n        uint256 resurrectionTime,\n        uint256 creationTime,\n        address indexed embalmer,\n        address indexed recipient,\n        address[] cursedArchaeologists,\n        uint256 totalDiggingFees,\n        string arweaveTxId\n    );\n\n    /// @notice Emitted when a sarcophagus is rewrapped\n    /// @param sarcoId Id of sarcophagus that was rewrapped\n    /// @param resurrectionTime New resurrection time for the sarcophagus\n    /// @param totalDiggingFees Total digging fees charged to the embalmer for the rewrap\n    /// @param rewrapSarcophagusProtocolFees Total protocol fees charged to the embalmer for the rewrap\n    event RewrapSarcophagus(\n        bytes32 indexed sarcoId,\n        uint256 resurrectionTime,\n        uint256 totalDiggingFees,\n        uint256 rewrapSarcophagusProtocolFees\n    );\n\n    /// @notice Emitted when a sarcophagus is buried\n    /// @param sarcoId Id of sarcophagus that was buried\n    event BurySarcophagus(bytes32 indexed sarcoId);\n\n    /// @notice Parameters of a sarcophagus, supplied during sarcophagus creation\n    struct SarcophagusParams {\n        string name;\n        // highest rewrap interval cursed archaeologists have agreed to accept for lifetime of sarcophagus\n        uint256 maximumRewrapInterval;\n        // The timestamp beyond which the sarcophagus can no longer be rewrapped\n        uint256 maximumResurrectionTime;\n        address recipientAddress;\n        uint256 resurrectionTime;\n        uint8 threshold;\n        uint256 creationTime;\n    }\n\n    /// @notice Parameters of an archaeologist's curse, supplied during sarcophagus creation\n    struct CurseParams {\n        bytes publicKey;\n        address archAddress;\n        uint256 diggingFeePerSecond;\n        uint256 curseFee;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with an id that is already in use\n    /// @param sarcoId Id that is already in use\n    error SarcophagusAlreadyExists(bytes32 sarcoId);\n\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with expired parameters\n    /// @param currentTime Timestamp of the failed create attempt\n    /// @param creationTime Time when the sarcophagus parameters were created\n    /// @param creationDeadline Deadline for creation of a sarcophagus with the supplied parameters\n    error SarcophagusParametersExpired(\n        uint256 currentTime,\n        uint256 creationTime,\n        uint256 creationDeadline\n    );\n\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with no archaeologists\n    error NoArchaeologistsProvided();\n\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with a shamir secret sharing threshold of 0\n    error ThresholdCannotBeZero();\n\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with more required archaeologists than total archaeologists\n    error ThresholdGreaterThanTotalNumberOfArchaeologists(\n        uint8 threshold,\n        uint256 totalNumberOfArchaeologists\n    );\n\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with an archaeologist list that contains the same archaeologist more than once\n    error ArchaeologistListContainsDuplicate(address archaeologistAddress);\n\n    /// @notice Emitted when an embalmer attempts to rewrap a sarcophagus with a resurrection time that has already passed\n    /// @param currentTime Timestamp of the failed rewrap attempt\n    /// @param resurrectionTime Resurrection timestamp which has already passed\n    error ResurrectionTimeInPast(uint256 currentTime, uint256 resurrectionTime);\n\n    /// @notice Emitted when an embalmer attempts to create a sarcophagus with a public key that has already been assigned to another sarcophagus\n    /// @param publicKey the duplicated public key\n    error DuplicatePublicKey(bytes publicKey);\n\n    /// @notice Emitted when an embalmer attempts to rewrap a sarcophagus with a resurrection time that exceeds the maximum rewrap interval\n    /// @param resurrectionTime Resurrection timestamp which is too far in the future\n    /// @param sarcophagusMaximumRewrapInterval Maximum rewrap interval set for the sarcophagus\n    /// @param maximumPermissibleResurrectionTime Resurrection timestamp which is too far in the future\n    error ResurrectionTimeTooFarInFuture(\n        uint256 resurrectionTime,\n        uint256 sarcophagusMaximumRewrapInterval,\n        uint256 maximumPermissibleResurrectionTime\n    );\n\n    /// @notice Emitted when the resurrection time defined during sarcohpagus creation or rewrap goes past the max resurrection time\n    /// @param resurrectionTime The resurrection time defined during the sarcophagus creation or rewrap\n    /// @param maxResurrectionTime The maximum allowed resurrection time\n    error ResurrectionTimePastMaxResurrectionTime(\n        uint256 resurrectionTime,\n        uint256 maxResurrectionTime\n    );\n\n    error NewResurrectionTimeInPast(uint256 currentTime, uint256 newResurrectionTime);\n\n    error NewResurrectionTimeIsZero();\n\n    error NewResurrectionTimeTooFarInFuture(\n        uint256 resurrectionTime,\n        uint256 sarcophagusMaximumRewrapInterval,\n        uint256 maximumPermissibleResurrectionTime\n    );\n\n    error ResurrectionTimeTooFarPastPreviousResurrectionTime(\n        uint256 resurrectionTime,\n        uint256 previousResurrectionTime\n    );\n\n    /// @notice Creates a sarcophagus with the supplied parameters and locks\n    /// a portion of each archaeologist's freeBond equal to the digging fees calculated for the duration\n    /// of the sarcophagus until its resurrection time.\n    ///\n    /// Verifies that each supplied archaeologist has signed off on the sarcophagus negotiation parameters:\n    ///    - `publicKey` that matches the private key the archaeologist is responsible for\n    ///    - `maximumRewrapInterval` to be enforced for the lifetime of the sarcophagus. No new resurrection time for future rewraps may exceed this interval from time of rewrap.\n    ///    - `creationTime` of sarcophagus\n    ///    - `diggingFeePerSecond` agreed to be paid to the archaeologist during the lifetime of the sarcophagus. Paid per rewrap and publishPrivateKey. Constant.\n    ///    - `curseFee` agreed to be paid to the archaeologist once during the lifetime of the sarcophagus to cover cost of publishPrivateKey tx. Paid either on first rewrap or publishPrivateKey if no rewrap has occurred Constant.\n    ///\n    /// @param sarcoId the identifier of the sarcophagus\n    /// @param sarcophagusParams params to set on sarcophagus being created\n    /// @param selectedArchaeologists the archaeologists the embalmer has selected to curse\n    /// @param arweaveTxId id of tx storing the sarcophagus payload on arweave\n    function createSarcophagus(\n        bytes32 sarcoId,\n        SarcophagusParams calldata sarcophagusParams,\n        CurseParams[] calldata selectedArchaeologists,\n        string calldata arweaveTxId\n    ) external {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        // Confirm that sarcophagus with supplied id doesn't already exist\n        if (s.sarcophagi[sarcoId].resurrectionTime != 0) {\n            revert SarcophagusAlreadyExists(sarcoId);\n        }\n\n        // Ensure too much time hasn't passed since the sarcophagus `creationTime` that has been signed\n        // off by its cursed archaeologists.\n        if (block.timestamp > sarcophagusParams.creationTime + s.expirationThreshold) {\n            revert SarcophagusParametersExpired(\n                block.timestamp,\n                sarcophagusParams.creationTime,\n                sarcophagusParams.creationTime + s.expirationThreshold\n            );\n        }\n\n        // Confirm that resurrection time is in the future\n        if (block.timestamp >= sarcophagusParams.resurrectionTime) {\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagusParams.resurrectionTime);\n        }\n\n        // Confirm that resurrection or rewrap will occur before the maximumRewrapInterval elapses\n        if (\n            block.timestamp + sarcophagusParams.maximumRewrapInterval <\n            sarcophagusParams.resurrectionTime\n        ) {\n            revert ResurrectionTimeTooFarInFuture(\n                sarcophagusParams.resurrectionTime,\n                sarcophagusParams.maximumRewrapInterval,\n                block.timestamp + sarcophagusParams.maximumRewrapInterval\n            );\n        }\n\n        // Confirm that the resurrection time is less than the max resurrection time\n        if (sarcophagusParams.resurrectionTime > sarcophagusParams.maximumResurrectionTime) {\n            revert ResurrectionTimePastMaxResurrectionTime(\n                sarcophagusParams.resurrectionTime,\n                sarcophagusParams.maximumResurrectionTime\n            );\n        }\n\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\n\n        // track total digging fees due upon creation of sarcophagus\n        uint256 totalDiggingFees;\n\n        {\n            uint256 nSelectedArchs = selectedArchaeologists.length;\n            // Validate archaeologist and threshold lengths\n            if (nSelectedArchs == 0) {\n                revert NoArchaeologistsProvided();\n            }\n\n            if (sarcophagusParams.threshold == 0) {\n                revert ThresholdCannotBeZero();\n            }\n\n            // Ensure that k <= n in the effective k-of-n shamir secret sharing scheme\n            // used to distribute keyshares among archaeologists\n            if (sarcophagusParams.threshold > nSelectedArchs) {\n                revert ThresholdGreaterThanTotalNumberOfArchaeologists(\n                    sarcophagusParams.threshold,\n                    nSelectedArchs\n                );\n            }\n\n            // create the sarcophagus\n            sarcophagus.name = sarcophagusParams.name;\n            sarcophagus.threshold = sarcophagusParams.threshold;\n            sarcophagus.resurrectionTime = sarcophagusParams.resurrectionTime;\n            sarcophagus.previousRewrapTime = sarcophagusParams.creationTime;\n            sarcophagus.maximumRewrapInterval = sarcophagusParams.maximumRewrapInterval;\n            sarcophagus.maximumResurrectionTime = sarcophagusParams.maximumResurrectionTime;\n            sarcophagus.arweaveTxId = arweaveTxId;\n            sarcophagus.embalmerAddress = msg.sender;\n            sarcophagus.recipientAddress = sarcophagusParams.recipientAddress;\n            sarcophagus.cursedArchaeologistAddresses = new address[](nSelectedArchs);\n            sarcophagus.cursedBondPercentage = s.cursedBondPercentage;\n\n            for (uint256 i; i < nSelectedArchs; ) {\n                LibUtils.revertIfArchProfileDoesNotExist(selectedArchaeologists[i].archAddress);\n\n                // Confirm archaeologist isn't already cursed on this sarcophagus (no duplicates)\n                if (\n                    sarcophagus\n                        .cursedArchaeologists[selectedArchaeologists[i].archAddress]\n                        .publicKey\n                        .length != 0\n                ) {\n                    revert ArchaeologistListContainsDuplicate(\n                        selectedArchaeologists[i].archAddress\n                    );\n                }\n\n                // Confirm archaeologist is not re-using a key pair\n                if (\n                    s.publicKeyToArchaeologistAddress[selectedArchaeologists[i].publicKey] !=\n                    address(0)\n                ) {\n                    revert DuplicatePublicKey(selectedArchaeologists[i].publicKey);\n                }\n\n                LibUtils.verifyArchaeologistSignature(\n                    sarcophagusParams.maximumRewrapInterval,\n                    sarcophagusParams.maximumResurrectionTime,\n                    sarcophagusParams.creationTime,\n                    selectedArchaeologists[i]\n                );\n\n                // Curse the archaeologist on this sarcophagus\n                uint256 diggingFeesDue = LibBonds.curseArchaeologist(\n                    sarcoId,\n                    selectedArchaeologists[i],\n                    i\n                );\n\n                totalDiggingFees += diggingFeesDue;\n\n                // \"Consume\" this public key so it cannot be reused in the future\n                s.publicKeyToArchaeologistAddress[\n                    selectedArchaeologists[i].publicKey\n                ] = selectedArchaeologists[i].archAddress;\n                unchecked {\n                    ++i;\n                }\n            }\n\n            // Transfer totalDiggingFees and the protocolFees in SARCO from embalmer to this contract\n            uint256 protocolFees = LibUtils.calculateProtocolFees(totalDiggingFees);\n            s.totalProtocolFees += protocolFees;\n            s.sarcoToken.transferFrom(\n                msg.sender,\n                address(this),\n                totalDiggingFees + protocolFees\n            );\n        }\n        emit CreateSarcophagus(\n            sarcoId,\n            sarcophagusParams.name,\n            sarcophagusParams.resurrectionTime,\n            sarcophagusParams.creationTime,\n            msg.sender,\n            sarcophagusParams.recipientAddress,\n            sarcophagus.cursedArchaeologistAddresses,\n            totalDiggingFees,\n            arweaveTxId\n        );\n    }\n\n    /// @notice Updates the resurrectionTime on a sarcophagus. Callable by the embalmer of a sarcophagus if its\n    /// resurrection time has not passed, it has not been compromised by k or more accusals, and it has not been buried.\n    /// @param sarcoId the identifier of the sarcophagus\n    /// @param resurrectionTime the new resurrection time\n    function rewrapSarcophagus(bytes32 sarcoId, uint256 resurrectionTime) external {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\n\n        // Confirm the sarcophagus exists\n        if (sarcophagus.resurrectionTime == 0) {\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\n        }\n\n        // Confirm the sarcophagus has not been compromised\n        if (sarcophagus.isCompromised) {\n            revert LibErrors.SarcophagusCompromised(sarcoId);\n        }\n\n        // Confirm the sarcophagus is not buried\n        if (sarcophagus.resurrectionTime == type(uint256).max) {\n            revert LibErrors.SarcophagusInactive(sarcoId);\n        }\n\n        // Confirm tx sender is embalmer\n        if (sarcophagus.embalmerAddress != msg.sender) {\n            revert LibErrors.SenderNotEmbalmer(msg.sender, sarcophagus.embalmerAddress);\n        }\n\n        // Confirm resurrection time has not yet passed\n        if (block.timestamp >= sarcophagus.resurrectionTime) {\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagus.resurrectionTime);\n        }\n\n        // Confirm that new resurrection time is in future\n        if (block.timestamp >= resurrectionTime) {\n            revert NewResurrectionTimeInPast(block.timestamp, resurrectionTime);\n        }\n\n        // Confirm that new resurrection time doesn't exceed sarcophagus's maximumRewrapInterval\n        if (block.timestamp + sarcophagus.maximumRewrapInterval < resurrectionTime) {\n            revert NewResurrectionTimeTooFarInFuture(\n                resurrectionTime,\n                sarcophagus.maximumRewrapInterval,\n                block.timestamp + sarcophagus.maximumRewrapInterval\n            );\n        }\n\n        // Confirm that the new resurrection time doesn't exceed the maximumResurrectionTime\n        if (sarcophagus.maximumResurrectionTime < resurrectionTime) {\n            revert ResurrectionTimePastMaxResurrectionTime(\n                resurrectionTime,\n                sarcophagus.maximumResurrectionTime\n            );\n        }\n\n        // track total digging fees to be paid by embalmer across all archaeologists on the sarcophagus\n        uint256 totalDiggingFees;\n\n        // pay digging fee to each cursed archaeologist on the sarcophagus that has not been accused\n        address[] storage archaeologistAddresses = sarcophagus.cursedArchaeologistAddresses;\n        uint256 cursedBondPercentage = sarcophagus.cursedBondPercentage;\n\n        uint256 nArchAddresses = archaeologistAddresses.length;\n        for (uint256 i; i < nArchAddresses; ) {\n            LibTypes.CursedArchaeologist storage cursedArchaeologist = sarcophagus\n                .cursedArchaeologists[archaeologistAddresses[i]];\n\n            if (!cursedArchaeologist.isAccused) {\n                // Previous digging fees calculation ignores curseFee\n                // curseFee rewards and bond are handled separately if this sarcophagus has not been rewrapped yet\n                uint256 prevDiggingFees = cursedArchaeologist.diggingFeePerSecond *\n                    (sarcophagus.resurrectionTime - sarcophagus.previousRewrapTime);\n\n                uint256 newDiggingFees = cursedArchaeologist.diggingFeePerSecond *\n                    (resurrectionTime - block.timestamp);\n\n                // If the new digging fees are greater than the previous digging fees, we need to\n                // increase the archaeologist's cursed bond to cover the necessary cursed bond amount\n                if (newDiggingFees > prevDiggingFees) {\n                    uint256 cursedBondIncrease = ((newDiggingFees - prevDiggingFees) *\n                        cursedBondPercentage) / 10000;\n\n                    // If the previous cycle's rewards can't cover the cursed bond increase, revert\n                    if (cursedBondIncrease > prevDiggingFees) {\n                        revert ResurrectionTimeTooFarPastPreviousResurrectionTime(\n                            resurrectionTime,\n                            sarcophagus.resurrectionTime\n                        );\n                    }\n\n                    // Increase the archaeologist's cursed bond using digging fees paid by the embalmer\n                    s.archaeologistProfiles[archaeologistAddresses[i]]\n                        .cursedBond += cursedBondIncrease;\n\n                    // Rewards are now previous digging fees - difference\n                    s.archaeologistRewards[archaeologistAddresses[i]] += (prevDiggingFees - cursedBondIncrease);\n                } else if (newDiggingFees < prevDiggingFees) {\n                    // New digging fees are less than the previous digging fees, so some of the cursed bond can be unlocked\n                    uint256 cursedBondDecrease = ((prevDiggingFees - newDiggingFees) *\n                        cursedBondPercentage) / 10000;\n\n                    // Decrease archaeologist's cursed bond by the difference\n                    s\n                        .archaeologistProfiles[archaeologistAddresses[i]]\n                        .cursedBond -= cursedBondDecrease;\n\n                    // Increase archaeologist's free bond by the difference\n                    s\n                        .archaeologistProfiles[archaeologistAddresses[i]]\n                        .freeBond += cursedBondDecrease;\n\n                    // Rewards are equal to the previous digging fees\n                    s.archaeologistRewards[archaeologistAddresses[i]] += prevDiggingFees;\n                } else {\n                    // Rewards are equal to the previous digging fees, the cursed bond can remain the same\n                    s.archaeologistRewards[archaeologistAddresses[i]] += prevDiggingFees;\n                }\n\n                // Add digging fees due for the new interval\n                totalDiggingFees += newDiggingFees;\n\n                // If sarcophagus has not been rewrapped yet, pay out the curseFee\n                if (!sarcophagus.isRewrapped) {\n                    // Pay archaeologists the curse fee to their rewards\n                    s.archaeologistRewards[archaeologistAddresses[i]] += cursedArchaeologist.curseFee;\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        uint256 protocolFees = LibUtils.calculateProtocolFees(totalDiggingFees);\n\n        // Add the protocol fee to the total protocol fees in storage\n        s.totalProtocolFees += protocolFees;\n\n        // Update the sarcophagus resurrectionTime and previousRewrapTime\n        sarcophagus.resurrectionTime = resurrectionTime;\n        sarcophagus.previousRewrapTime = block.timestamp;\n\n        if (!sarcophagus.isRewrapped) {\n            sarcophagus.isRewrapped = true;\n        }\n\n        // Transfer the new digging fees and protocol fees from embalmer to contract\n        s.sarcoToken.transferFrom(msg.sender, address(this), totalDiggingFees + protocolFees);\n\n        emit RewrapSarcophagus(sarcoId, resurrectionTime, totalDiggingFees, protocolFees);\n    }\n\n    /// @notice Terminates a sarcophagus by setting its resurrection time to infinity and returning locked\n    /// bonds to all innocent cursed archaeologists. Callable by the embalmer of a sarcophagus if its\n    /// resurrection time has not passed, it has not been compromised by k or more accusals, and it has not been buried.\n    /// @param sarcoId the identifier of the sarcophagus\n    function burySarcophagus(bytes32 sarcoId) external {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\n\n        // Confirm the sarcophagus exists\n        if (sarcophagus.resurrectionTime == 0) {\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\n        }\n\n        // Confirm the sarcophagus has not been compromised\n        if (sarcophagus.isCompromised) {\n            revert LibErrors.SarcophagusCompromised(sarcoId);\n        }\n\n        // Confirm the sarcophagus is not buried\n        if (sarcophagus.resurrectionTime == type(uint256).max) {\n            revert LibErrors.SarcophagusInactive(sarcoId);\n        }\n\n        // Confirm tx sender is embalmer\n        if (sarcophagus.embalmerAddress != msg.sender) {\n            revert LibErrors.SenderNotEmbalmer(msg.sender, sarcophagus.embalmerAddress);\n        }\n        // Confirm that the current resurrection time is in the future\n        if (block.timestamp >= sarcophagus.resurrectionTime) {\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagus.resurrectionTime);\n        }\n\n        // for each archaeologist on the sarcophagus, unlock bond and pay digging fees\n        address[] storage archaeologistAddresses = sarcophagus.cursedArchaeologistAddresses;\n        uint256 nArchAddresses = archaeologistAddresses.length;\n        for (uint256 i; i < nArchAddresses; ) {\n            LibTypes.CursedArchaeologist storage cursedArchaeologist = sarcophagus\n                .cursedArchaeologists[archaeologistAddresses[i]];\n\n            // if the archaeologist hasn't been accused transfer them their digging fees and return their locked bond\n            if (!cursedArchaeologist.isAccused) {\n                LibBonds.freeArchaeologist(sarcoId, archaeologistAddresses[i]);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Set resurrection time to infinity\n        sarcophagus.resurrectionTime = type(uint256).max;\n\n        emit BurySarcophagus(sarcoId);\n    }\n}\n"
    },
    "contracts/facets/ThirdPartyFacet.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.18;\n\nimport {LibDiamond} from \"hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../libraries/LibTypes.sol\";\nimport {LibErrors} from \"../libraries/LibErrors.sol\";\nimport {LibBonds} from \"../libraries/LibBonds.sol\";\nimport {LibUtils} from \"../libraries/LibUtils.sol\";\nimport \"../storage/LibAppStorage.sol\";\nimport \"../libraries/LibTypes.sol\";\n\ncontract ThirdPartyFacet {\n    event AccuseArchaeologist(\n        bytes32 indexed sarcoId,\n        address indexed accuser,\n        uint256 totalSlashedBondDistributed,\n        uint256 totalDiggingFeesDistributed,\n        address[] accusedArchAddresses\n    );\n\n    event Clean(bytes32 indexed sarcoId, address indexed cleaner);\n\n    /// @notice Clean has been called on a sarcophagus that has already been cleaned\n    /// @param sarcoId ID of sarcophagus archaeologist has attempted to publish a private key on\n    error SarcophagusAlreadyCleaned(bytes32 sarcoId);\n\n    /// @notice Clean has been called before the deadline for archaeologists to publish private keys has passed\n    /// @param currentTime Timestamp of the failed clean attempt\n    /// @param publishDeadline Latest time an archaeologist may publish a private key on a sarcophagus: resurrectionTime + gracePeriod\n    error TooEarlyForClean(uint256 currentTime, uint256 publishDeadline);\n\n    /// @notice Clean has been called by someone other than the admin or embalmer of the sarcophagus\n    /// @param senderAddress Address of sender\n    error SenderNotEmbalmerOrAdmin(address senderAddress);\n\n    /// @notice Embalmer has attempted to clean a sarcophagus after the embalmerClaimWindow has passed\n    /// @param currentTime Timestamp of the failed clean attempt\n    /// @param embalmerClaimWindowEnd Latest time an embalmer may claim residual locked bonds the sarcophagus: resurrectionTime + gracePeriod + embalmerClaimWindow\n    error EmbalmerClaimWindowPassed(uint256 currentTime, uint256 embalmerClaimWindowEnd);\n\n    /// @notice Admin has attempted to clean a sarcophagus before the embalmerClaimWindow has passed\n    /// @param currentTime Timestamp of the failed clean attempt\n    /// @param embalmerClaimWindowEnd Latest time an embalmer may claim residual locked bonds the sarcophagus: resurrectionTime + gracePeriod + embalmerClaimWindow\n    error TooEarlyForAdminClean(uint256 currentTime, uint256 embalmerClaimWindowEnd);\n\n    /// @notice Emitted when a third party attempts to accuse an archaeologist on a sarcophagus where the resurrection time has already passed\n    /// @param currentTime Timestamp of the failed accuse attempt\n    /// @param resurrectionTime Resurrection timestamp which has already passed\n    error ResurrectionTimeInPast(uint256 currentTime, uint256 resurrectionTime);\n\n    /// @notice Emitted when accuse is called with an unequal numbers of public keys and signatures\n    /// @param signatures the number of signatures passed into the accuse call\n    /// @param publicKeys the number of public keys passed into the accuse call\n    error DifferentNumberOfSignaturesAndPublicKeys(uint256 signatures, uint256 publicKeys);\n\n    /// @notice Emitted when accuse is called with an invalid signature for the supplied sarcoId, paymentAddress, and publicKey\n    /// @param sarcoId that should have been signed\n    /// @param paymentAddress payment address that should have been signed\n    /// @param publicKey publicKey that should be derived from signing key\n    /// @param signature invalid signature\n    error InvalidAccusalSignature(\n        bytes32 sarcoId,\n        address paymentAddress,\n        bytes publicKey,\n        LibTypes.Signature signature\n    );\n\n    /// @notice If archaeologists fail to publish their private keys on a sarcophagus before the end of the gracePeriod,\n    /// their locked bonds and diggingFees may be claimed by either the embalmer or the admin\n    /// embalmers may claim during a limited embalmerClaimWindow after the end of the gracePeriod, after that only the admin will\n    /// be able to claim remaining locked bond and diggingFees\n    /// @param sarcoId The identifier of the sarcophagus to clean\n    function clean(bytes32 sarcoId) external {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\n\n        // Confirm the sarcophagus exists\n        if (sarcophagus.resurrectionTime == 0) {\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\n        }\n\n        // Confirm tx sender is embalmer or admin\n        if (msg.sender != sarcophagus.embalmerAddress && msg.sender != LibDiamond.contractOwner()) {\n            revert SenderNotEmbalmerOrAdmin(msg.sender);\n        }\n\n        // Confirm the sarcophagus has not been compromised\n        if (sarcophagus.isCompromised) {\n            revert LibErrors.SarcophagusCompromised(sarcoId);\n        }\n\n        // Confirm the sarcophagus is not buried\n        if (sarcophagus.resurrectionTime == type(uint256).max) {\n            revert LibErrors.SarcophagusInactive(sarcoId);\n        }\n\n        // Confirm the sarcophagus has not already been cleaned\n        if (sarcophagus.isCleaned) {\n            revert SarcophagusAlreadyCleaned(sarcoId);\n        }\n\n        // Confirm that the resurrectionTime + gracePeriod have passed\n        if (block.timestamp <= sarcophagus.resurrectionTime + s.gracePeriod) {\n            revert TooEarlyForClean(block.timestamp, sarcophagus.resurrectionTime + s.gracePeriod);\n        }\n\n        // if sender is embalmer, confirm current time is within embalmerClaimWindow\n        if (\n            msg.sender == sarcophagus.embalmerAddress &&\n            block.timestamp > sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\n        ) {\n            revert EmbalmerClaimWindowPassed(\n                block.timestamp,\n                sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\n            );\n        }\n\n        // if sender is admin, confirm embalmerClaimWindow has passed\n        if (\n            msg.sender == LibDiamond.contractOwner() &&\n            block.timestamp <= sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\n        ) {\n            revert TooEarlyForAdminClean(\n                block.timestamp,\n                sarcophagus.resurrectionTime + s.gracePeriod + s.embalmerClaimWindow\n            );\n        }\n\n        // sum of locked bonds and digging fees for all archaeologists that have failed to publish private keys before publish deadline and have not been accused\n        uint256 totalDiggingFeesAndLockedBonds;\n        uint256 nCursedArchs = sarcophagus.cursedArchaeologistAddresses.length;\n\n        for (uint256 i; i < nCursedArchs; ) {\n            LibTypes.CursedArchaeologist storage cursedArchaeologist = sarcophagus\n                .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]];\n\n            // Punish archaeologists that failed to publish their private key in time\n            if (!cursedArchaeologist.isAccused && cursedArchaeologist.privateKey == 0) {\n                uint256 diggingFeesDue = cursedArchaeologist.diggingFeePerSecond *\n                    (sarcophagus.resurrectionTime - sarcophagus.previousRewrapTime);\n\n                if (!sarcophagus.isRewrapped) {\n                    diggingFeesDue += cursedArchaeologist.curseFee;\n                }\n\n                uint256 cursedBondDue = (diggingFeesDue * sarcophagus.cursedBondPercentage) / 10000;\n                totalDiggingFeesAndLockedBonds += diggingFeesDue + cursedBondDue;\n\n                // slash the archaeologist's locked bond for the sarcophagus\n                s.archaeologistProfiles[sarcophagus.cursedArchaeologistAddresses[i]].cursedBond -= cursedBondDue;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Transfer total slashed locked bonds plus digging fees to the embalmer if they are the caller, otherwise add\n        // this to the contract's protocol fees\n        if (msg.sender == sarcophagus.embalmerAddress) {\n            s.sarcoToken.transfer(sarcophagus.embalmerAddress, totalDiggingFeesAndLockedBonds);\n        } else {\n            s.totalProtocolFees += totalDiggingFeesAndLockedBonds;\n        }\n\n        sarcophagus.isCleaned = true;\n        emit Clean(sarcoId, msg.sender);\n    }\n\n    /**\n     * @notice Accuse one or more archaeologists of leaking private keys by submitting signatures on the sarco id\n     * and payment address generated with the leaked private keys\n     * If the archaeologists responsible for those private keys haven't already been accused, their locked bond will be\n     * split between the embalmer and the supplied payment address and digging fees allocated for those archaeologists will be refunded to the embalmer\n     *\n     * If k or more archaeologists are accused over the lifetime of a sarcophagus, the sarcophagus\n     * state will be updated to Accused and bonds for all remaining unaccused archaeologists will be\n     * returned\n     *\n     * @param sarcoId The identifier of the sarcophagus having leaked private keys\n     * @param publicKeys an array of public keys corresponding to leaked private keys - order must match order of signatures\n     * @param signatures an array of signatures of the sarcoId and payment address signed by the leaked private keys - order must match order of publicKeys\n     * @param paymentAddress the address to which rewards should be sent if successful\n     */\n    function accuse(\n        bytes32 sarcoId,\n        bytes[] calldata publicKeys,\n        LibTypes.Signature[] calldata signatures,\n        address paymentAddress\n    ) external {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\n\n        // Confirm sarcophagus exists\n        if (sarcophagus.resurrectionTime == 0) {\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\n        }\n\n        // verify that current time is not past resurrection time\n        if (block.timestamp > sarcophagus.resurrectionTime) {\n            revert ResurrectionTimeInPast(block.timestamp, sarcophagus.resurrectionTime);\n        }\n\n        // Confirm the sarcophagus has not been compromised\n        if (sarcophagus.isCompromised) {\n            revert LibErrors.SarcophagusCompromised(sarcoId);\n        }\n\n        // Confirm the sarcophagus is not buried\n        if (sarcophagus.resurrectionTime == type(uint256).max) {\n            revert LibErrors.SarcophagusInactive(sarcoId);\n        }\n\n        uint256 nSigs = signatures.length;\n\n        if (nSigs != publicKeys.length) {\n            revert DifferentNumberOfSignaturesAndPublicKeys(nSigs, publicKeys.length);\n        }\n\n        address[] memory accusedArchAddresses = new address[](nSigs);\n\n        // track the combined locked bond across all archaeologists being accused in this call\n        uint256 totalCursedBond;\n        uint256 accusalCount;\n        for (uint256 i; i < nSigs; ) {\n            if (\n                !LibUtils.verifyAccusalSignature(\n                    sarcoId,\n                    paymentAddress,\n                    publicKeys[i],\n                    signatures[i]\n                )\n            ) {\n                revert InvalidAccusalSignature(\n                    sarcoId,\n                    paymentAddress,\n                    publicKeys[i],\n                    signatures[i]\n                );\n            }\n\n            // look up the archaeologist responsible for the publicKey\n            address accusedArchaeologistAddress = s.publicKeyToArchaeologistAddress[publicKeys[i]];\n            LibTypes.CursedArchaeologist storage accusedArchaeologist = sarcophagus\n                .cursedArchaeologists[accusedArchaeologistAddress];\n\n            // verify the accused archaeologist is cursed on the sarcophagus\n            if (accusedArchaeologist.publicKey.length == 0) {\n                revert LibErrors.ArchaeologistNotOnSarcophagus(msg.sender);\n            }\n\n            // if the archaeologist has already been accused on this sarcophagus skip them without taking action\n            if (accusedArchaeologist.isAccused) {\n                unchecked {\n                    ++i;\n                }\n                continue;\n            }\n\n            // mark the archaeologist on the sarcophagus as having been accused\n            accusedArchaeologist.isAccused = true;\n            accusedArchAddresses[accusalCount++] = accusedArchaeologistAddress;\n\n            uint256 cursedBondDue = ((accusedArchaeologist.diggingFeePerSecond *\n                (sarcophagus.resurrectionTime - sarcophagus.previousRewrapTime)) *\n                sarcophagus.cursedBondPercentage) / 10000;\n\n            // If the sarcophagus has not been rewrapped, also slash the curse fee\n            if (!sarcophagus.isRewrapped) {\n                cursedBondDue += accusedArchaeologist.curseFee * sarcophagus.cursedBondPercentage / 10000;\n            }\n\n            totalCursedBond += cursedBondDue;\n\n            // Slash the offending archaeologists bond\n            s.archaeologistProfiles[accusedArchaeologistAddress].cursedBond -= cursedBondDue;\n            unchecked {\n                ++i;\n            }\n        }\n\n        // if none of the accusals were valid because the archaeologists have all already been accused, return without taking action\n        if (accusalCount == 0) {\n            return;\n        }\n\n        {\n            uint256 nCursedArchs = sarcophagus.cursedArchaeologistAddresses.length;\n\n            // the sarcophagus is compromised if the current call has successfully accused the sss threshold of archaeologists\n            if (accusalCount >= sarcophagus.threshold) {\n                sarcophagus.isCompromised = true;\n            } else {\n                // if the current call hasn't resulted in at least sss threshold archaeologists being accused\n                // check if total number of historical accusals on sarcophagus is greater than threshold\n                uint256 totalAccusals;\n\n                for (uint256 i; i < nCursedArchs; ) {\n                    if (\n                        sarcophagus\n                            .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]]\n                            .isAccused\n                    ) {\n                        ++totalAccusals;\n                    }\n                    unchecked {\n                        ++i;\n                    }\n                }\n                // the sarcophagus is compromised if k or more archaeologists have been accused over the lifetime of the sarcophagus\n                if (totalAccusals >= sarcophagus.threshold) {\n                    sarcophagus.isCompromised = true;\n                }\n            }\n\n            // if k or more archaeologists have been accused over the lifetime of the sarcophagus, funds should\n            // be returned to the remaining well behaved archaeologists\n            if (sarcophagus.isCompromised) {\n                // iterate through all archaeologist addresses on the sarcophagus\n                for (uint256 i; i < nCursedArchs; ) {\n                    // if the archaeologist has never been accused, release their locked bond back to them\n                    if (\n                        !sarcophagus\n                            .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]]\n                            .isAccused\n                    ) {\n                        LibBonds.freeArchaeologist(\n                            sarcoId,\n                            sarcophagus.cursedArchaeologistAddresses[i]\n                        );\n                    }\n                    unchecked {\n                        ++i;\n                    }\n                }\n            }\n        }\n\n        uint256 halfTotalCursedBond = totalCursedBond >> 1;\n        uint256 totalDiggingFees = totalCursedBond / (sarcophagus.cursedBondPercentage / 10000);\n        // transfer the cursed half, plus the current digging fees, to the embalmer\n        s.sarcoToken.transfer(\n            sarcophagus.embalmerAddress,\n            totalDiggingFees + halfTotalCursedBond\n        );\n\n        // transfer the other half of the cursed bond to the transaction caller\n        s.sarcoToken.transfer(paymentAddress, halfTotalCursedBond);\n\n        emit AccuseArchaeologist(\n            sarcoId,\n            msg.sender,\n            totalCursedBond,\n            totalDiggingFees,\n            accusedArchAddresses\n        );\n    }\n}\n"
    },
    "contracts/facets/ViewStateFacet.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.18;\n\nimport \"../libraries/LibTypes.sol\";\nimport \"../libraries/LibUtils.sol\";\nimport \"../storage/LibAppStorage.sol\";\n\ncontract ViewStateFacet {\n    /// @notice Get the admin address from diamond storage\n    /// @return The admin address\n    function getAdmin() external view returns (address) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        return s.admin;\n    }\n\n    /// @notice Gets the total protocol fees from diamond storage\n    /// @return The total protocol fees\n    function getTotalProtocolFees() external view returns (uint256) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        return s.totalProtocolFees;\n    }\n\n    /// @notice Get the protocol fee base percentage from diamond storage\n    /// @return The protocol fee base percentage - protocolFeeBasePercentage\n    function getProtocolFeeBasePercentage() external view returns (uint256) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        return s.protocolFeeBasePercentage;\n    }\n\n    /// @notice Get the cursed bond percentage from diamond storage\n    /// @return The cursed bond percentage - cursedBondPercentage\n    function getCursedBondPercentage() external view returns (uint256) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        return s.cursedBondPercentage;\n    }\n\n    /// @notice Gets archaeologist profiles given a list of archaeologist addresses.\n    /// If an invalid address is included, simply leaves it out of the list.\n    /// @param addresses The list of archaeologist addresses\n    /// @return The list of archaeologist profiles\n    function getArchaeologistProfiles(\n        address[] memory addresses\n    ) external view returns (LibTypes.ArchaeologistProfile[] memory) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        uint256 nAddresses = addresses.length;\n        LibTypes.ArchaeologistProfile[] memory profiles = new LibTypes.ArchaeologistProfile[](\n            nAddresses\n        );\n\n        for (uint256 i; i < nAddresses; ) {\n            // Skip unregistered archaeologists\n            if (s.archaeologistProfiles[addresses[i]].maximumRewrapInterval == 0) {\n                continue;\n            }\n            profiles[i] = s.archaeologistProfiles[addresses[i]];\n            unchecked {\n                ++i;\n            }\n        }\n\n        return profiles;\n    }\n\n    /// @notice Gets the grace period an archaeologist is given to resurrect a sarcophagus after the resurrection time passes\n    /// @return The resurrection grace period\n    function getGracePeriod() external view returns (uint256) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        return s.gracePeriod;\n    }\n\n    /// @notice Gets the window after end of gracePeriod + resurrectionTime where embalmer can claim remaining bonds from archaeologists that have failed to publish private keys\n    /// @return The embalmer claim window\n    function getEmbalmerClaimWindow() external view returns (uint256) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        return s.embalmerClaimWindow;\n    }\n\n    /// @notice Gets the expiration threshold after which a sarcophagus must be renegotiated\n    /// @return The expiration threshold\n    function getExpirationThreshold() external view returns (uint256) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        return s.expirationThreshold;\n    }\n\n    /// @notice Given an archaeologist address, return that archaeologist's\n    /// profile\n    /// @param archaeologist The archaeologist account's address\n    /// @return the Archaeologist object\n    function getArchaeologistProfile(\n        address archaeologist\n    ) external view returns (LibTypes.ArchaeologistProfile memory) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        LibUtils.revertIfArchProfileDoesNotExist(archaeologist);\n        return s.archaeologistProfiles[archaeologist];\n    }\n\n    /// @notice Return the list of registereed archaeologist addresses.\n    /// @return addresses of registered archaeologists\n    function getArchaeologistProfileAddresses() external view returns (address[] memory) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        return s.archaeologistProfileAddresses;\n    }\n\n    /// @notice Given an index (of the full archaeologist array), return the\n    /// archaeologist address at that index\n    /// @param index The index of the registered archaeologist\n    /// @return address of the archaeologist\n    function getArchaeologistProfileAddressAtIndex(uint256 index) external view returns (address) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        return s.archaeologistProfileAddresses[index];\n    }\n\n    /// @notice Returns the amount of free bond stored in the contract for an\n    /// archaeologist.\n    /// @param archaeologist The address of the archaeologist whose\n    /// free bond is being returned\n    function getFreeBond(address archaeologist) external view returns (uint256) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        return s.archaeologistProfiles[archaeologist].freeBond;\n    }\n\n    /// @notice Returns the amount of rewards stored in the contract for an\n    /// archaeologist.\n    /// @param archaeologist The address of the archaeologist whose\n    /// reward is being returned\n    function getRewards(address archaeologist) external view returns (uint256) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        return s.archaeologistRewards[archaeologist];\n    }\n\n    /// @notice Returns the amount of cursed bond stored in the contract for an\n    /// archaeologist.\n    /// @param archaeologist The address of the archaeologist whose\n    /// cursed bond is being returned\n    function getCursedBond(address archaeologist) external view returns (uint256) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        return s.archaeologistProfiles[archaeologist].cursedBond;\n    }\n\n    struct SarcophagusResponse {\n        uint256 resurrectionTime;\n        uint256 previousRewrapTime;\n        bool isCompromised;\n        bool isCleaned;\n        string name;\n        uint8 threshold;\n        uint256 maximumRewrapInterval;\n        uint256 maximumResurrectionTime;\n        uint256 cursedBondPercentage;\n        string arweaveTxId;\n        address embalmerAddress;\n        address recipientAddress;\n        address[] archaeologistAddresses;\n        uint8 publishedPrivateKeyCount;\n        bool hasLockedBond;\n    }\n\n    /// @notice Returns data on the sarcophagus with the supplied id\n    /// includes aggregate data on cursed archaeologists associated with the sarcophagus\n    ///     - publishedPrivateKeyCount - the total number of private keys published by archaeologists on the sarcophagus\n    ///     - hasLockedBond - true if archaeologists still have bond locked in the contract for this sarcophagus\n    /// @param sarcoId The identifier of the sarcophagus being returned\n    function getSarcophagus(bytes32 sarcoId) external view returns (SarcophagusResponse memory) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\n\n        // Confirm sarcophagus exists\n        if (sarcophagus.resurrectionTime == 0) {\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\n        }\n\n        uint8 publishedPrivateKeyCount;\n        bool hasLockedBond;\n        uint256 archsLength = sarcophagus.cursedArchaeologistAddresses.length;\n        for (uint256 i; i < archsLength; ) {\n            // archaeologist has published a private key\n            if (\n                sarcophagus\n                    .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]]\n                    .privateKey != 0\n            ) {\n                ++publishedPrivateKeyCount;\n            } else if (\n                !sarcophagus\n                    .cursedArchaeologists[sarcophagus.cursedArchaeologistAddresses[i]]\n                    .isAccused &&\n                !sarcophagus.isCompromised &&\n                !sarcophagus.isCleaned &&\n                sarcophagus.resurrectionTime != type(uint256).max\n            ) {\n                // if the sarcophagus is not compromised, buried, or cleaned and\n                // one or more unaccused archaeologists hasn't published a private key there is locked bond on the sarcophagus\n                hasLockedBond = true;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        return\n            SarcophagusResponse({\n                resurrectionTime: sarcophagus.resurrectionTime,\n                previousRewrapTime: sarcophagus.previousRewrapTime,\n                isCompromised: sarcophagus.isCompromised,\n                isCleaned: sarcophagus.isCleaned,\n                name: sarcophagus.name,\n                threshold: sarcophagus.threshold,\n                maximumRewrapInterval: sarcophagus.maximumRewrapInterval,\n                maximumResurrectionTime: sarcophagus.maximumResurrectionTime,\n                cursedBondPercentage: sarcophagus.cursedBondPercentage,\n                arweaveTxId: sarcophagus.arweaveTxId,\n                embalmerAddress: sarcophagus.embalmerAddress,\n                recipientAddress: sarcophagus.recipientAddress,\n                archaeologistAddresses: sarcophagus.cursedArchaeologistAddresses,\n                publishedPrivateKeyCount: publishedPrivateKeyCount,\n                hasLockedBond: hasLockedBond\n            });\n    }\n\n    /// @notice Returns the data stored on a sarcophagus for an archaeologist.\n    /// @param sarcoId The identifier of the sarcophagus whose data is being\n    /// returned\n    /// @param archaeologist The address of the archaeologist whose data is\n    /// being returned\n    function getSarcophagusArchaeologist(\n        bytes32 sarcoId,\n        address archaeologist\n    ) external view returns (LibTypes.CursedArchaeologist memory) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        return s.sarcophagi[sarcoId].cursedArchaeologists[archaeologist];\n    }\n}\n"
    },
    "contracts/libraries/LibBonds.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.18;\n\nimport \"../storage/LibAppStorage.sol\";\nimport \"../libraries/LibTypes.sol\";\nimport {LibErrors} from \"./LibErrors.sol\";\n\nimport \"../facets/EmbalmerFacet.sol\";\n\nlibrary LibBonds {\n    /// @notice Bonds the archaeologist to a sarcophagus.\n    /// This does the following:\n    ///   - adds the archaeologist's curse params and address to the sarcophagus\n    ///   - calculates digging fees to be locked and later paid to archaeologist (includes curseFee)\n    ///   - locks this amount from archaeologist's free bond; increases cursedBond by same\n    ///   - Adds the sarcophagus' id to the archaeologist's record of bonded sarcophagi\n    /// @param sarcoId Id of the sarcophagus with which to curse the archaeologist\n    /// @param archaeologist The archaeologist to curse, with associated parameters of the curse\n    ///\n    /// @return the amount of digging fees due the embalmer for this curse\n    function curseArchaeologist(\n        bytes32 sarcoId,\n        EmbalmerFacet.CurseParams calldata archaeologist,\n        uint256 index\n    ) internal returns (uint256) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\n\n        sarcophagus.cursedArchaeologists[archaeologist.archAddress] = LibTypes.CursedArchaeologist({\n            publicKey: archaeologist.publicKey,\n            privateKey: 0,\n            isAccused: false,\n            diggingFeePerSecond: archaeologist.diggingFeePerSecond,\n            curseFee: archaeologist.curseFee\n        });\n        sarcophagus.cursedArchaeologistAddresses[index] = archaeologist.archAddress;\n\n        // Calculate digging fees due for this time period (creationTime/previousRewrapTime -> resurrectionTime)\n        uint256 diggingFeesDue = (archaeologist.diggingFeePerSecond *\n            (sarcophagus.resurrectionTime - sarcophagus.previousRewrapTime))\n            + archaeologist.curseFee;\n\n        // Use cursed bond percentage to determine how much bond to lock up\n        uint256 bondToCurse = (((diggingFeesDue) * s.cursedBondPercentage) / 10000);\n\n        // Transfer bond to curse from free bond to cursed bond\n        s.archaeologistProfiles[archaeologist.archAddress].freeBond -= bondToCurse;\n        s.archaeologistProfiles[archaeologist.archAddress].cursedBond += bondToCurse;\n\n        return diggingFeesDue;\n    }\n\n    /// @notice Calculates and unlocks an archaeologist's cursed bond. Pays due digging fees to the archaeologist.\n    /// @param sarcoId the identifier of the sarcophagus to free the archaeologist from\n    /// @param archaeologistAddress the address of the archaeologist to free\n    function freeArchaeologist(bytes32 sarcoId, address archaeologistAddress) internal {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n        LibTypes.Sarcophagus storage sarcophagus = s.sarcophagi[sarcoId];\n\n        LibTypes.CursedArchaeologist storage cursedArchaeologist = s\n            .sarcophagi[sarcoId]\n            .cursedArchaeologists[archaeologistAddress];\n\n        // Calculate the digging fees to be paid since the last rewrap (or creation)\n        uint256 diggingFeeAmount = cursedArchaeologist.diggingFeePerSecond *\n            (sarcophagus.resurrectionTime - sarcophagus.previousRewrapTime);\n\n        // Include curse fee in bond amount being released\n        uint256 cursedBondAmount = ((diggingFeeAmount + cursedArchaeologist.curseFee) * sarcophagus.cursedBondPercentage) / 10000;\n\n        s.archaeologistProfiles[archaeologistAddress].cursedBond -= cursedBondAmount;\n        s.archaeologistProfiles[archaeologistAddress].freeBond += cursedBondAmount;\n\n        // If sarcophagus has not be been rewrapped yet, pay out the curseFee\n        if (!sarcophagus.isRewrapped) {\n            diggingFeeAmount += cursedArchaeologist.curseFee;\n        }\n\n        s.archaeologistRewards[archaeologistAddress] += diggingFeeAmount;\n    }\n}\n"
    },
    "contracts/libraries/LibErrors.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.18;\n\n/**\n * @title A collection of Errors\n * @notice This library defines all of the Errors that the Sarcophagus system\n * uses.\n */\nlibrary LibErrors {\n    error ArchaeologistNotOnSarcophagus(address archaeologist);\n\n    error NotEnoughCursedBond(uint256 cursedBond, uint256 amount);\n\n    error NotEnoughFreeBond(uint256 freeBond, uint256 amount);\n\n    error ArchaeologistProfileExistsShouldBe(bool exists, address archaeologist);\n\n    error SarcophagusDoesNotExist(bytes32 sarcoId);\n\n    error SarcophagusInactive(bytes32 sarcoId);\n\n    error SarcophagusCompromised(bytes32 sarcoId);\n\n    error SenderNotEmbalmer(address sender, address embalmer);\n\n    error InvalidSignature(\n        // address recovered from signature via ecrecover\n        address recoveredAddress,\n        // address we expected to have signed the data\n        address expectedAddress\n    );\n}\n"
    },
    "contracts/libraries/LibPrivateKeys.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\n/**\n * @title Private key verification\n * @notice Implements a private key -> public key checking function\n * @dev modified from https://github.com/1Address/ecsol, removes extra code\n * which isn't necessary for our Sarcophagus implementation\n */\nlibrary LibPrivateKeys {\n    /**\n     * @notice Given a private key and a public key, determines if that public\n     * key was derived from the private key\n     * @dev based on https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384/9\n     * @param privKey an secp256k1 private key\n     * @param pubKey an uncompressed 65 byte secp256k1 public key\n     * @return bool indicating whether the public key is derived from the\n     * private key\n     */\n    function isPublicKeyOfPrivateKey(\n        bytes32 privKey,\n        bytes storage pubKey\n    ) internal view returns (bool) {\n        // removes the 0x04 prefix from an uncompressed public key\n        uint256 pubKeyLength = pubKey.length;\n        bytes memory truncatedPublicKey = new bytes(pubKeyLength - 1);\n        for (uint256 i = 1; i < pubKeyLength; ) {\n            truncatedPublicKey[i - 1] = pubKey[i];\n            unchecked {\n                ++i;\n            }\n        }\n\n        // generator point coordinates and order of secp256k1\n        uint256 gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798;\n        uint256 gy = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8;\n        uint256 m = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;\n\n        address signer = ecrecover(\n            0,\n            gy % 2 != 0 ? 28 : 27,\n            bytes32(gx),\n            bytes32(mulmod(uint256(privKey), gx, m))\n        );\n\n        address xyAddress = address(\n            uint160(\n                uint256(keccak256(truncatedPublicKey)) &\n                    0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n            )\n        );\n        return xyAddress == signer;\n    }\n}\n"
    },
    "contracts/libraries/LibTypes.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.18;\n\n/**\n * @title Types shared across facets for the Sarcophagus diamond\n */\nlibrary LibTypes {\n    struct Sarcophagus {\n        // Also used for existence checks -- does not exist if 0\n        uint256 resurrectionTime;\n        uint256 previousRewrapTime;\n        // todo: run gas cost evaluation on storing isCompromised vs looping through stored archaeologists and checking isAccused\n        bool isCompromised;\n        bool isCleaned;\n        bool isRewrapped;\n        uint8 threshold;\n        string name;\n        uint256 maximumRewrapInterval;\n        uint256 maximumResurrectionTime;\n        string arweaveTxId;\n        address embalmerAddress;\n        address recipientAddress;\n        address[] cursedArchaeologistAddresses;\n        mapping(address => CursedArchaeologist) cursedArchaeologists;\n        uint256 cursedBondPercentage;\n    }\n\n    struct CursedArchaeologist {\n        uint256 diggingFeePerSecond;\n        // Also used for publish checks -- has not published if 0\n        bytes32 privateKey;\n        // Also used for curse checks -- is not bonded if length is 0\n        bytes publicKey;\n        bool isAccused;\n        uint256 curseFee;\n    }\n\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct ArchaeologistProfile {\n        // Also used for existence checks -- does not exist if 0\n        uint256 maximumRewrapInterval;\n        uint256 maximumResurrectionTime;\n        string peerId;\n        uint256 minimumDiggingFeePerSecond;\n        uint256 freeBond;\n        uint256 cursedBond;\n        uint256 curseFee;\n    }\n}\n"
    },
    "contracts/libraries/LibUtils.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.18;\n\nimport \"../storage/LibAppStorage.sol\";\nimport \"../libraries/LibTypes.sol\";\nimport {LibErrors} from \"../libraries/LibErrors.sol\";\nimport \"../facets/ThirdPartyFacet.sol\";\nimport \"./LibTypes.sol\";\nimport \"../facets/EmbalmerFacet.sol\";\n\n/**\n * @title Utility functions used within the Sarcophagus system\n * @notice This library implements various functions that are used throughout\n * Sarcophagus, mainly to DRY up the codebase\n * @dev these functions are all stateless, public, pure/view\n */\nlibrary LibUtils {\n    /**\n     * @notice The archaeologist needs to sign off on two pieces of data\n     * to guarantee their unrwap will be successful\n     *\n     * @param agreedMaximumRewrapInterval that the archaeologist has agreed to for the sarcophagus\n     * @param timestamp that the archaeologist has agreed to for the sarcophagus\n     * @param curseParams parameters of curse signed by archaeologist\n     */\n    function verifyArchaeologistSignature(\n        uint256 agreedMaximumRewrapInterval,\n        uint256 maximumResurrectionTime,\n        uint256 timestamp,\n        EmbalmerFacet.CurseParams calldata curseParams\n    ) internal pure {\n        // Hash the hash of the data payload\n        bytes32 messageHash = keccak256(\n            abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n32\",\n                keccak256(\n                    abi.encode(\n                        curseParams.publicKey,\n                        agreedMaximumRewrapInterval,\n                        maximumResurrectionTime,\n                        curseParams.diggingFeePerSecond,\n                        timestamp,\n                        curseParams.curseFee\n                    )\n                )\n            )\n        );\n\n        // Generate the address from the signature.\n        // ecrecover should always return a valid address.\n        address recoveredAddress = ecrecover(\n            messageHash,\n            curseParams.v,\n            curseParams.r,\n            curseParams.s\n        );\n\n        if (recoveredAddress != curseParams.archAddress) {\n            revert LibErrors.InvalidSignature(recoveredAddress, curseParams.archAddress);\n        }\n    }\n\n    /// @notice Verifies that a signature and public key were created from the same private key\n    /// @param sarcoId the sarcoId that was signed\n    /// @param paymentAddress the payment address that was signed\n    /// @param publicKey an uncompressed 65 byte secp256k1 public key\n    /// @param signature signature on the sarco id and payment address\n    /// @return true if the signature was signed by the private key corresponding to the supplied public key\n    function verifyAccusalSignature(\n        bytes32 sarcoId,\n        address paymentAddress,\n        bytes calldata publicKey,\n        LibTypes.Signature calldata signature\n    ) internal pure returns (bool) {\n        // removes the 0x04 prefix from an uncompressed public key\n        uint256 pubKeyLength = publicKey.length;\n        bytes memory truncatedPublicKey = new bytes(pubKeyLength - 1);\n        for (uint256 i = 1; i < pubKeyLength; ) {\n            truncatedPublicKey[i - 1] = publicKey[i];\n            unchecked {\n                ++i;\n            }\n        }\n        bytes32 messageHash = keccak256(\n            abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n32\",\n                keccak256(abi.encode(sarcoId, paymentAddress))\n            )\n        );\n        // Use ecrecover to get the address that signed the message\n        address signingAddress = ecrecover(messageHash, signature.v, signature.r, signature.s);\n\n        address publicKeyAddress = address(\n            uint160(\n                uint256(keccak256(truncatedPublicKey)) &\n                    0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n            )\n        );\n\n        return signingAddress == publicKeyAddress;\n    }\n\n    /// @notice Checks if an archaeologist profile exists and\n    /// reverts if so\n    ///\n    /// @param archaeologist the archaeologist address to check existence of\n    function revertIfArchProfileExists(address archaeologist) internal view {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        if (s.archaeologistProfiles[archaeologist].maximumRewrapInterval != 0) {\n            revert LibErrors.ArchaeologistProfileExistsShouldBe(false, archaeologist);\n        }\n    }\n\n    /// @notice Checks if an archaeologist profile doesn't exist and reverts if so\n    ///\n    /// @param archaeologist the archaeologist address to check lack of existence of\n    function revertIfArchProfileDoesNotExist(address archaeologist) internal view {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        if (s.archaeologistProfiles[archaeologist].maximumRewrapInterval == 0) {\n            revert LibErrors.ArchaeologistProfileExistsShouldBe(true, archaeologist);\n        }\n    }\n\n    /// @notice Calculates the protocol fees to be taken from the embalmer.\n    /// @param totalDiggingFees to be paid. Protocol fee is a percentage of this\n    /// @return The protocol fees amount\n    function calculateProtocolFees(uint256 totalDiggingFees) internal view returns (uint256) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        return (totalDiggingFees * s.protocolFeeBasePercentage) / 10000;\n    }\n}\n"
    },
    "contracts/proxy/LibUtilsProxy.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.18;\n\nimport {LibUtils} from \"../libraries/LibUtils.sol\";\nimport {LibTypes} from \"../libraries/LibTypes.sol\";\n\ncontract LibUtilsTest {\n    function verifySignature(\n        bytes32 sarcoId,\n        address paymentAddress,\n        bytes calldata publicKey,\n        LibTypes.Signature calldata signature\n    ) external pure returns (bool) {\n        return LibUtils.verifyAccusalSignature(sarcoId, paymentAddress, publicKey, signature);\n    }\n}\n"
    },
    "contracts/storage/AppStorageInit.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./LibAppStorage.sol\";\n\ncontract AppStorageInit {\n    /// @notice Initializes the app with default state values\n    /// @dev Add any AppStorage struct properties here to initialize values\n    function init(\n        IERC20 sarcoToken,\n        address admin,\n        uint256 protocolFeeBasePercentage,\n        uint256 cursedBondPercentage,\n        uint256 gracePeriod,\n        uint256 embalmerClaimWindow,\n        uint256 expirationThreshold\n    ) external {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        s.sarcoToken = sarcoToken;\n        s.admin = admin;\n        s.protocolFeeBasePercentage = protocolFeeBasePercentage;\n        s.cursedBondPercentage = cursedBondPercentage;\n        s.gracePeriod = gracePeriod;\n        s.embalmerClaimWindow = embalmerClaimWindow;\n        s.expirationThreshold = expirationThreshold;\n    }\n}\n"
    },
    "contracts/storage/LibAppStorage.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../libraries/LibTypes.sol\";\n\n/**\n * Global diamond storage struct to be shared across facets\n */\nstruct AppStorage {\n    // SARCO token contract\n    IERC20 sarcoToken;\n    // The Admin address allowed to call Admin Facet functions\n    address admin;\n    // total protocol fees available to be withdrawn by the admin\n    uint256 totalProtocolFees;\n    /**\n     * Protocol level admin configurations\n     */\n    // % of total digging fees for sarcophagus to charge embalmer on create and rewrap. Denominator is 10000\n    uint256 protocolFeeBasePercentage;\n    // % of digging fees archaeologists must have locked up per curse in cursed bond. Denominator is 10000\n    uint256 cursedBondPercentage;\n    // grace period an archaeologist is given to resurrect a sarcophagus after the resurrection time. Specified in seconds\n    uint256 gracePeriod;\n    // threshold after which archaeologist signatures on sarcophagus params expire and the sarcophagus must be renegotiated. Specified in seconds\n    uint256 expirationThreshold;\n    // window after end of gracePeriod + resurrectionTime where embalmer can claim remaining bonds from archaeologists that have failed to publish private keys. Specified in seconds\n    uint256 embalmerClaimWindow;\n    // registered archaeologist addresses\n    address[] archaeologistProfileAddresses;\n    // public key => archaeologist address\n    mapping(bytes => address) publicKeyToArchaeologistAddress;\n    // sarcophagus id => sarcophagus object\n    mapping(bytes32 => LibTypes.Sarcophagus) sarcophagi;\n    // archaeologist address => profile\n    mapping(address => LibTypes.ArchaeologistProfile) archaeologistProfiles;\n    // current balance of rewards available for the archaeologist to withdraw\n    mapping(address => uint256) archaeologistRewards;\n}\n\nlibrary LibAppStorage {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"sarcophagus.storage.1\");\n\n    function getAppStorage() internal pure returns (AppStorage storage s) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            s.slot := position\n        }\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.8/diamond/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n    enum FacetCutAction {Add, Replace, Remove}\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    struct DiamondStorage {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    // Internal function version of diamondCut\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();        \n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);            \n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n            removeFunction(ds, oldFacetAddress, selector);\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(ds, oldFacetAddress, selector);\n        }\n    }\n\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\n        enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\n        ds.facetAddresses.push(_facetAddress);\n    }    \n\n\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \n        require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n        // an immutable function is a function defined directly in a diamond\n        require(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete ds.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            ds.facetAddresses.pop();\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            require(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but_calldata is not empty\");\n        } else {\n            require(_calldata.length > 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\");\n            if (_init != address(this)) {\n                enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n            }\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\n            if (!success) {\n                if (error.length > 0) {\n                    // bubble up the error\n                    revert(string(error));\n                } else {\n                    revert(\"LibDiamondCut: _init function reverted\");\n                }\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}